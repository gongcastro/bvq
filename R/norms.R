#' Generate item-level norms for age, sex, language profile and item dominance
#'
#' This function generates a data frame with the estimated proportion of
#' children that understand and/or produce some items for a selected age range
#' and participant profiles. Estimated proportions and corresponding standard
#' errors and confidence intervals are computed adjusting for zero- and
#' one-inflation (see function [bvq::prop_adj()]).
#'
#' @export bvq_norms
#'
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr select
#' @importFrom dplyr left_join
#' @importFrom dplyr summarise
#' @importFrom dplyr arrange
#' @importFrom tidyr pivot_longer
#' @param responses Responses data frame, as generated by [bvq::bvq_responses()].
#' @param participants Participants data frame, as generated by
#'   [bvq::bvq_participants()]
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]>. Unquote name of the variable(s) to group
#'   data into. Norms will be calculated by aggregating responses
#'   within the groups that result from the combination of crossing of the
#'   variables provided in `...`. These variables can refer to item properties
#'   (see [bvq::pool], e.g., `semantic_category`) or to participant properties (see
#'   [bvq::bvq_logs()], e.g., `lp`).
#' @param te Translation equivalent for which the norms should be computed.
#'  * If NULL (default), norms are computed exclusively for the items indicated in `item`.
#'  * If TRUE, norms are computed for both the item indicated in the `item` argument, and for its translation.
#'  * If FALSE, norms are computed exclusively for the items indicated in `item` (same as NULL)
#'  * If numeric vector, norms are computed for all items corresponding to the translation equivalents indicated in this argument.
#' @param item Character string indicating the item to compute norms for. If
#'   left `NULL` (default) norms will be computed for all items. You can check
#'   the available items in the [bvq::pool] data set running `data("pool")`.
#' @param age Numeric vector of length two (*min*-*max*) indicating the age range of
#'   participants to compute norms for.
#'
#' @returns A data frame (actually, a [tibble::tibble] with the proportion of
#'   participants in the sample that understand or produce the items indicated
#'   in `item`, or the translation equivalents indicated in `te`.
#' The output contains the following variables:
#' * te: an integer identifying the translation equivalent (a.k.a., pair of cross-language synonyms, doublets) the item belongs to.
#' * item: character string indicating the item identifier (e.g., `spa_mesa`). This value is unique for each item. Responses to the same item from different participants are linked by the same `item` value.
#' * language: a character string indicating the language the item response belongs to: `"Catalan"` if item in Catalan), `"Spanish"` if item in Spanish.
#' * age: an numeric vector of length 1 or 2 indicating the age range of participants (in months) for which the estimates should be computed. If a non-integer is provided (e.g., `15.36`, it is rounded downwards using [floor()].)
#' * type: a character string indicating the vocabulary type computed: `"understands"` if option 'Understands' was selected, and `"produces"` if option 'Understands & Says' was selected.
#' * item_dominance: a character string that takes the value `"L1"` if the item belongs to participants' language of most exposure, and L2 if the item belongs to participants' language of least exposure.
#' * label: a character string indicating the text presented to participants in the questionnaire (replacing the `item` identifier).
#' * .sum: a positive integer indicating the number of positive responses: `responses` is 2 (Understands) or 3 (Understands & Says) for `type = "understands"`, and 3 (Understands & Says) if `type = "produces"`.
#' * .n: a positive integer indicating the total number number of responses (useful for computing proportions).
#' * .prop: a numeric value ranging from 0 to 1 (both included) indicating the estimated proportion of participants that provided a positive response, adjusted following Gelman et al.'s method to account for zero- and one-inflation (see function [prop_adj]).
#' Additionally, any variables specified in the `.by` argument are preserved as grouping variables.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @examples
#' \dontrun{
#' responses <- bvq_responses()
#' 
#' bvq_norms(
#'     participants = participants,
#'     responses = responses,
#'     item = "cat_casa",
#'     age = c(22, 22),
#'     lp
#' )
#'     
#' my_items <- c("cat_gos", "cat_gat")
#' 
#' bvq_norms(
#'     participants = participants,
#'     responses = responses,
#'     item = my_items,
#'     te = TRUE,
#'     age = c(15, 16)
#' )    
#' }
#' 
#' @md
bvq_norms <- function(participants = NULL,
                      responses = NULL,
                      ...,
                      te = NULL,
                      item = NULL,
                      age = c(0, 100)) {
    
    if (is.null(participants)) participants <- bvq_participants()
    if (is.null(responses)) responses <- bvq_responses(participants)
    
    # collect ... into a character vector for `any_of`
    dots_vctr <- as.character(match.call(expand.dots = FALSE)$`...`)
    
    group_vars <- c("te", "item", "label", "age", "type", "item_dominance", dots_vctr)
    
    # retrieve participants and logs -------------------------------------------
    
    logs_tmp <- bvq_logs(participants = participants, responses = responses)
    cols.keep <-  colnames(logs_tmp) %in% c("id", "time", "dominance", group_vars)
    logs_tmp <- logs_tmp[, cols.keep]
    logs_tmp$age <- floor(logs_tmp$age)
    logs_tmp <- logs_tmp[logs_tmp$age >= min(age) & logs_tmp$age <= max(age), ]
    
    cols.keep <- colnames(bvq::pool) %in% c("language", group_vars)
    pool_tmp <- bvq::pool[, cols.keep]
    
    # check arguments ----------------------------------------------------------
    
    if (is.null(item)) {
        item <- unique(responses$item)
    } else {
        item_in_pool <- item %in% unique(pool_tmp$item)
        if (!all(item_in_pool)) {
            item_not_in_pool <- paste0(item[which(!item_in_pool)], collapse = ", ")
            cli_abort("item(?s) `{item_not_in_pool}` {?does/do} not exist in pool")
        }
    }
    
    if (is.null(age)) age <- floor(range(logs_tmp$age, na.rm = TRUE))
    
    item <- check_arg_te(te, item)
    
    if (length(age) < 1 || length(age) > 2|| !is.numeric(age)) {
        cli_abort("`age` must be a numeric vector of length  1 or 2")
    }
    
    # compute norms ------------------------------------------------------------
    
    responses_tmp <- responses[responses$item %in% item &
                                   !is.na(responses$response), ]
    responses_tmp$understands <- responses_tmp$response > 1
    responses_tmp$produces <- responses_tmp$response > 2
    responses_tmp <- responses_tmp[, colnames(responses_tmp)!="response"]
    responses_tmp <- tidyr::pivot_longer(responses_tmp,
                                         c(understands, produces),
                                         names_to = "type",
                                         values_to = "response")
    
    
    norms <- merge(responses_tmp, logs_tmp) 
    norms <- merge(norms, pool_tmp, all.x = TRUE)
    
    norms$item_dominance <- ifelse(norms$language==norms$dominance, "L1", "L2")
    norms <- summarise(norms,
                       .sum = sum(response, na.rm = TRUE),
                       .n = n(),
                       .by = any_of(group_vars))
    norms$.prop <- prop_adj(norms$.sum, norms$.n)
    norms <- norms[order(norms$te,
                         norms$item,
                         norms$type, 
                         norms$age,
                         decreasing = TRUE), , drop = FALSE]
    norms <- tibble::as_tibble(norms)
    
    return(norms)
}

#' Check argument `te` in [bvq::bvq_norms()] function
#'
#' @importFrom cli  cli_alert_warning
#'
#' @param te Translation equivalent for which the norms should be computed.
#'  * If NULL (default), norms are computed exclusively for the items indicated in `item`.
#'  * If TRUE, norms are computed for both the item indicated in the `item` argument, and for its translation.
#'  * If FALSE, norms are computed exclusively for the items indicated in `item` (same as NULL)
#'  * If numeric vector, norms are computed for all items corresponding to the translation equivalents indicated in this argument.
#' @param item Character string indicating the item to compute norms for. If
#'   left `NULL` (default) norms will be computed for all items. You can check
#'   the available items in the [bvq::pool] data set running `data("pool")`.
#'   
#' @noRd
#' @keywords internal
#' 
check_arg_te <- function(te, item) { # nocov start
    if (is.logical(te)) {
        if (te) {
            item <- pool$item[pool$te %in% pool$te[pool$item %in% item]]
            return(item)
        }
    } else if (is.numeric(te)) {
        te_in_pool <- te %in% unique(pool$te)
        if (!all(te_in_pool)) {
            te_not_in_pool <- te[which(!te_in_pool)]
            cli_abort("te{?s} {te_not_in_pool} {?does/do} not exist in pool")
        } else {
            items_not_in_te <- item %in% pool$item[pool$te %in% te]
            if (!all(items_not_in_te)) {
                which_items_not_in_te <- item[which(!items_not_in_te)]
                error_msg <- "Item{?s} '{which_items_not_in_te}' {?was/were} not included in `te`. \\
                Its norms will not be returned. To compute the norms for all `items` \\
                and their translations, set {.code te = TRUE}."
                cli_alert_warning(error_msg)
            }
            item <- pool$item[pool$te %in% te]
            return(item)
        }
    } else {
        if (!is.null(te)) {
            cli_abort("`te` must have class {.cls logical} or {.cls integer}")
        }
    }
    return(item)
} # nocov end
