#' Generate item-level norms for age, sex, language profile and item dominance
#'
#' This function generates a data frame with the estimated proportion of
#' children that understand and/or produce some items for a selected age range
#' and participant profiles. Estimated proportions and corresponding standard
#' errors and confidence intervals are computed adjusting for zero- and
#' one-inflation (see function [prop_adj()]).
#'
#' @export bvq_norms
#'
#' @importFrom dplyr mutate
#' @importFrom dplyr filter
#' @importFrom dplyr select
#' @importFrom dplyr left_join
#' @importFrom dplyr summarise
#' @importFrom dplyr arrange
#' @importFrom tidyr pivot_longer
#' @param responses Responses data frame, as generated by [bvq::bvq_responses()].
#' @param participants Participants data frame, as generated by
#'   [bvq::bvq_participants()]
#' @param te Translation equivalent for which the norms should be computed.
#'  * If NULL (default), norms are computed exclusively for the items indicated in `item`.
#'  * If TRUE, norms are computed for both the item indicated in the `item` argument, and for its translation.
#'  * If FALSE, norms are computed exclusively for the items indicated in `item` (same as NULL)
#'  * If numeric vector, norms are computed for all items corresponding to the translation equivalents indicated in this argument.
#' @param item Character string indicating the item to compute norms for. If
#'   left `NULL` (default) norms will be computed for all items. You can check
#'   the available items in the [bvq::pool] data set running `data("pool")`.
#' @param age Numeric vector of length two (*min*-*max*) indicating the age range of
#'   participants to compute norms for.
#' @param .by A character vector that takes the name of the variable(s) to group
#'   data into. Norms will be calculated by aggregating responses
#'   within the groups that result from the combination of crossing of the
#'   variables provided in `.by`. These variables can refer to item properties
#'   (see [bvq::pool], e.g., `"semantic_category"`) or to participant properties (see
#'   [bvq_logs()], e.g., `"lp"`).
#' @param ... Unused
#'
#' @returns A data frame (actually, a [tibble::tibble] with the proportion of
#'   participants in the sample that understand or produce the items indicated
#'   in `item`, or the translation equivalents indicated in `te`.
#' The output contains the following variables:
#' * te: an integer identifying the translation equivalent (a.k.a., pair of cross-language synonyms, doublets) the item belongs to.
#' * item: character string indicating the item identifier (e.g., `spa_mesa`). This value is unique for each item. Responses to the same item from different participants are linked by the same `item` value.
#' * language: a character string indicating the language the item response belongs to: `"Catalan"` if item in Catalan), `"Spanish"` if item in Spanish.
#' * age: an numeric vector of length two indicating the age range of participants (in months) for which the estimates should be computed. If a non-integer is provided (e.g., `15.36`, it is rounded downwards using [floor()].)
#' * type: a character string indicating the vocabulary type computed: `"understands"` if option 'Understands' was selected, and `"produces"` if option 'Understands & Says' was selected.
#' * item_dominance: a character string that takes the value `"L1"` if the item belongs to participants' language of most exposure, and L2 if the item belongs to participants' language of least exposure.
#' * label: a character string indicating the text presented to participants in the questionnaire (replacing the `item` identifier).
#' * .sum: a positive integer indicating the number of positive responses: `responses` is 2 (Understands) or 3 (Understands & Says) for `type = "understands"`, and 3 (Understands & Says) if `type = "produces"`.
#' * .n: a positive integer indicating the total number number of responses (useful for computing proportions).
#' * .prop: a numeric value ranging from 0 to 1 (both included) indicating the estimated proportion of participants that provided a positive response, adjusted following Gelman et al.'s method to account for zero- and one-inflation (see function [prop_adj]).
#' Additionally, any variables specified in the `.by` argument are preserved as grouping variables.
#' @author Gonzalo Garcia-Castro
#' @md
bvq_norms <- function(participants,
                      responses,
                      te = NULL,
                      item = NULL,
                      age = NULL,
                      .by = NULL,
                      ...) {
    
    group_vars <- c("te", "item", "label", "age", "type", "item_dominance", .by)
    
    # retrieve participants and logs -------------------------------------------
    logs_tmp <- bvq_logs(participants = participants, 
                         responses = responses) %>% 
        select(id, time, dominance, any_of(group_vars)) %>% 
        mutate(age = floor(age))
    
    pool_tmp <- select(bvq::pool, language, any_of(group_vars))
    
    # check arguments ----------------------------------------------------------
    
    if (is.null(item)) {
        item <- unique(responses$item)
    } else{
        item_in_pool <- item %in% unique(pool_tmp$item)
        if (!all(item_in_pool)) {
            item_not_in_pool <- paste0(item[which(!item_in_pool)], collapse = ", ")
            cli_abort("item `{item_not_in_pool}` does not exist in pool")
        }
    }
    
    if (is.null(age)) age <- floor(range(logs_tmp$age, na.rm = TRUE))
    
    item <- check_arg_te(te, item)
    
    if (length(age) != 2 || !is.numeric(age)) {
        cli_abort("`age` must be a numeric vector of length 2")
    } 
    
    # compute norms ------------------------------------------------------------
    
    norms <- responses %>%
        left_join(logs_tmp, by = join_by(id, time), multiple = "all") %>%
        filter(item %in% .env$item,
               !is.na(response),
               age >= .env$age[1],
               age <= .env$age[2]) %>% 
        mutate(understands = response > 1,
               produces = response==3) %>% 
        select(-response) %>% 
        pivot_longer(c(understands, produces),
                     names_to = "type", 
                     values_to = "response") %>%
        left_join(pool_tmp, 
                  relationship = "many-to-many",
                  by = join_by(item)) %>%
        mutate(item_dominance = ifelse(language==dominance, "L1", "L2")) %>%
        summarise(.sum = sum(response, na.rm = TRUE),
                  .n = n(),
                  .by = any_of(group_vars)) %>%
        mutate(.prop = prop_adj(.sum, .n)) %>% 
        arrange(te, item, item_dominance, type, age, .sum, .n, .prop) 
    
    return(norms)
    
}

#' Check argument `te` in [bvq::bvq_norms()] function
#' 
#' @importFrom cli  cli_alert_warning
#' 
#' @param te Translation equivalent for which the norms should be computed.
#'  * If NULL (default), norms are computed exclusively for the items indicated in `item`.
#'  * If TRUE, norms are computed for both the item indicated in the `item` argument, and for its translation.
#'  * If FALSE, norms are computed exclusively for the items indicated in `item` (same as NULL)
#'  * If numeric vector, norms are computed for all items corresponding to the translation equivalents indicated in this argument.
#' @param item Character string indicating the item to compute norms for. If
#'   left `NULL` (default) norms will be computed for all items. You can check
#'   the available items in the [bvq::pool] data set running `data("pool")`.
#'   
check_arg_te <- function(te, item) 
{
    if (is.logical(te)) {
        if (te) {
            item <- pool$item[pool$te %in% pool$te[pool$item %in% item]]
            return(item)
        }
    } else if (is.numeric(te)) {
        te_in_pool <- te %in% unique(pool_tmp$te)
        if (!all(te_in_pool)) {
            te_not_in_pool <- paste0(te[which(!te_in_pool)], collapse = ", ")
            cli_abort("te{?s} {te_not_in_pool} does not exist in pool")
        } else {
            items_not_in_te <- item %in% pool$item[pool$te %in% te]
            if (!all(items_not_in_te)) {
                which_items_not_in_te <- paste0(item[which(!items_not_in_te)], collapse = ", ")
                cli_alert_warning("Item{?s} '{which_items_not_in_te}' was not included in the specified `te`.
                                  Its norms will not be returned.
                                  To compute the norms for all `items` and their translations, set `te = TRUE`.")
                
            }
            item <- pool$item[pool$te %in% te]
            return(item)
        }
    } else {
        if (!is.null(te)) {
            cli_abort("`te` must be logical or integer")
        }
    }
    return(item)
}
