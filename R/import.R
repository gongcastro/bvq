#' Download formr surveys
#'
#' @importFrom cli cli_progress_done
#' @importFrom cli cli_progress_step
#' @importFrom cli cli_progress_update
#' @importFrom cli qty
#'
#' @param surveys Name of the surveys in the formr run.
#' @param ... Unused.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#' 
#' @md
download_surveys <- function(surveys, ...) {
    n <- length(surveys)
    i <- 0
    raw <- vector(mode = "list", length = n)
    
    if (interactive()) {
        step_msg <- "Downloaded {i}/{n} {qty(i)}survey{?s}"
        cli_progress_step(msg = step_msg)
    }
    
    for (i in seq_along(surveys)) {
        raw[[i]] <- formr_raw_results(surveys[i])
        if (interactive()) cli_progress_update()
    }
    
    if (interactive()) cli_progress_done(result = "done")
    
    raw <- lapply(raw, select, -any_of("language"))
    names(raw) <- surveys
    
    return(raw)
}

#' Process survey contents
#'
#' @param raw Raw survey data, as generated by [bvq::download_surveys()]
#' @param participants_tmp Participants dataset, inherited from inside the `import_*()` function environment.
#' @param survey_name character string indicating the name of the survey being processed (must be `"BL-Lockdown"`, `"BL-Short"`, or `"BL-Long-2"`).
#' 
#' @importFrom dplyr if_any
#'
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#' 
#' @md
process_survey <- function(raw, participants_tmp, survey_name) {
    words_cat <- select(raw[[6]], session, created_cat = created, ended_cat = ended)
    words_spa <- select(raw[[7]], session, created_spa = created, ended_spa = ended)
    
    raw_tmp <- raw %>%
        lapply(select, -one_of(c("created", "modified", "ended", "expired"))) %>%
        # if a single session ID has multiple entries, select most recent
        reduce(inner_join, by = join_by(session), multiple = "all") %>%
        mutate(survey_name = .env$survey_name,
               version = ifelse(survey_name == "BL-Long-2",
                                survey_name,
                                paste(survey_name,
                                      trimws(version, whitespace = "[\\h\\v]"),
                                      sep = "-"
                                ))) %>% 
        left_join(participants_tmp, by = join_by(code))
    
    items_to_keep <- c(
        "time", "code", "study", "version", "randomisation",
        "date_birth", "date_started", "date_finished", "sex",
        "edu_parent1", "edu_parent2", "language_doe_catalan",
        "language_doe_spanish", "language_doe_others"
    )
    
    # process data
    processed <- raw_tmp %>%
        select(-matches("lockdown")) %>%
        left_join(words_cat, by = join_by(session), multiple = "all") %>%
        left_join(words_spa, by = join_by(session), multiple = "all") %>%
        dplyr::filter(code %in% participants_tmp$code,
                      !if_any(matches("created_|ended_"), is.na)) %>% 
        mutate(across(c(matches("created_|ended_"), date_birth),
                      as_datetime),
               across(starts_with("language_doe"),
                      function(x) ifelse(is.na(x), 0, x)),
               survey_name = .env$survey_name,
               date_started = get_time_stamp(ended_cat,
                                             ended_spa,
                                             which = "first"),
               date_finished = get_time_stamp(ended_cat,
                                              ended_spa,
                                              which = "last"),
               language_doe_catalan = get_doe(matches("catalan")),
               language_doe_spanish = get_doe(matches("spanish")),
               language_doe_others = 100 - rowSums(across(c(
                   language_doe_catalan,
                   language_doe_spanish
               )))) %>% 
        arrange(desc(date_finished)) %>%
        distinct(session, .keep_all = TRUE) %>%
        rename(edu_parent1 = demo_parent1,
               edu_parent2 = demo_parent2) %>%
        select(starts_with("id"),
               one_of(items_to_keep),
               starts_with("cat_"),
               starts_with("spa_")) %>%
        pivot_longer(cols = matches("cat_|spa_"),
                     names_to = "item",
                     values_to = "response") %>%
        rename_with(function(x) gsub("language_", "", x), everything()) %>%
        mutate(language = ifelse(grepl("cat_", item), "Catalan", "Spanish"),
               sex = ifelse(sex == 1, "Male", "Female"),
               across(starts_with("edu_"),
                      function(x) na_if(x, ""))) %>%
        arrange(desc(date_finished)) %>%
        distinct(id, code, item, .keep_all = TRUE) %>% 
        mutate(across(c(starts_with("id"), code, study, version, randomisation,
                        sex, edu_parent1, edu_parent2, item, language),
                      as.character))
    
    return(processed)
}

#' Import BVQ-v1.0.0 data
#'
#' @import dplyr
#' @importFrom formr formr_raw_results
#' @importFrom lubridate as_datetime
#' @importFrom lubridate time_length
#' @importFrom tidyr pivot_longer
#' @importFrom janitor clean_names
#' @importFrom rlang .env
#' @importFrom cli cli_alert_success
#' 
#' @param surveys Name of formr surveys from the `bvq` run.
#' @param ... Unused.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#'
#' @md
import_bvq_100 <- function(participants,
                           surveys = runs[["bvq-v1.0.0"]], 
                           ...) 
{
    version <- "bvq-v1.0.0"
    
    if (missing(participants)) participants <- bvq_participants()
    
    participants_tmp <- subset(participants, select = -version)
    
    # fetch responses
    raw <- download_surveys(surveys)
    names(raw[[1]])[names(raw[[1]]) == "bl_code"] <- "code"
    raw[[1]]$code <- fix_code(na_if(raw[[1]]$code, ""))
    raw[[1]]$created <- lubridate::as_datetime(raw[[1]]$created)
    raw[[1]] <- subset(raw[[1]], !is.na(code) & !is.na(ended))
    raw[[1]] <- fix_code_raw(raw[[1]]) # fix codes known to be wrong
    raw[[1]] <- raw[[1]][order(desc(raw[[1]]$created)), , drop = FALSE]
    # get only last response of each code
    raw[[1]] <- raw[[1]][!duplicated(raw[[1]]$code), , drop = FALSE]
    
    processed <- process_survey(raw, participants_tmp, version)
    
    if (interactive()) {
        n_responses <- nrow(distinct(processed, code))
        msg <- "{version} updated: {n_responses} response{?s} retrieved"
        cli_alert_success(msg)
    }
    
    return(processed)
}

#' Import BVQ-v0.5.0 data
#'
#' @import dplyr
#' @importFrom formr formr_raw_results
#' @importFrom lubridate as_datetime
#' @importFrom lubridate time_length
#' @importFrom tidyr pivot_longer
#' @importFrom janitor clean_names
#' @importFrom rlang .env
#' @importFrom cli cli_alert_success
#' 
#' @param surveys Name of formr surveys from the `bilexicon_lockdown` run.
#' @param ... Unused.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#'
#' @md
import_bvq_050 <- function(participants,
                           surveys = runs[["bvq-v0.5.0"]], 
                           ...) 
{
    version <- "bvq-v0.5.0"
    
    if (missing(participants)) participants <- bvq_participants()
    
    participants_tmp <- select(participants, -version)
    
    # fetch responses
    raw <- download_surveys(surveys)
    raw[[1]] <- raw[[1]] %>%
        rename(code = bl_code) %>%
        mutate(
            code = fix_code(na_if(code, "")), # fix codes known to be wrong
            created = as_datetime(created)
        ) %>%
        filter(!is.na(code), !is.na(ended)) %>% 
        fix_code_raw() %>% # fix codes known to be wrong
        # filter(code %in% participants_tmp$code) %>% # remove codes not included in participants
        arrange(desc(created)) %>%
        distinct(code, .keep_all = TRUE) # get only last response of each code
    
    processed <- process_survey(raw, participants_tmp, version)
    
    if (interactive()) {
        n_responses <- nrow(distinct(processed, code))
        msg <- "{version} updated: {n_responses} response{?s} retrieved"
        cli_alert_success(msg)
    }
    
    return(processed)
}


#' Import BVQ-0.4.0
#'
#' @import dplyr
#' @importFrom formr formr_raw_results
#' @importFrom lubridate as_datetime
#' @importFrom tidyr pivot_longer
#' @importFrom janitor clean_names
#' @importFrom rlang .env
#' @importFrom cli cli_alert_success
#' 
#' @param surveys Name of formr surveys from the `bilexicon_short` run
#' @param ... Unused.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#' 
#' @md
import_bvq_040 <- function(participants,
                           surveys = runs[["bvq-v0.4.0"]], 
                           ...) 
{
    version <- "bvq-v0.4.0"
    
    if (missing(participants)) participants <- bvq_participants()
    
    participants_tmp <- participants %>%
        filter(version %in% .env$version) %>%
        select(-version)
    
    # fetch responses
    raw <- download_surveys(surveys)
    
    # edit Spanish inventory
    raw[[7]] <- rename_all(raw[[7]], ~ gsub("cat_", "spa_", .))
    
    # edit logs dataset
    raw[[1]] <- raw[[1]] %>%
        # fix codes known to be wrong
        mutate(
            code = fix_code(na_if(code, "")),
            created = as_datetime(created)
        ) %>%
        # remove codes not inlcuded in participants
        filter(code %in% participants_tmp$code) %>%
        # get only last response of each code
        arrange(desc(created)) %>%
        distinct(code, .keep_all = TRUE) %>%
        # remove responses with no code
        filter(!is.na(code), !is.na(ended)) %>% 
        # fix codes known to be wrong
        fix_code_raw()
    
    processed <- process_survey(raw, participants_tmp, version)
    
    if (interactive()) {
        n_responses <- nrow(distinct(processed, code))
        msg <- "{version} updated: {n_responses} response{?s} retrieved"
        cli_alert_success(msg)
    }
    
    return(processed)
}

#' Import BVQ-v0.3.0
#'
#' @import dplyr
#' @importFrom formr formr_raw_results
#' @importFrom lubridate as_datetime
#' @importFrom tidyr pivot_longer
#' @importFrom janitor clean_names
#' @importFrom rlang .env
#' @importFrom cli cli_alert_success
#' 
#' @param surveys Name of formr surveys from the bilexicon_long2 run.
#' @param ... Unused.
#' 
#' @author Gonzalo Garcia-Castro
#' 
#' @noRd
#' @keywords internal
#' 
#' @md
import_bvq_030 <- function(participants, 
                           surveys = runs[["bvq-v0.3.0"]],
                          ...) {
    
    version <- "bvq-v0.3.0"
    
    if (missing(participants)) participants <- bvq_participants()
    
    participants_tmp <- participants %>% 
        filter(
            version %in% .env$version,
            randomisation %in% "2"
        ) %>%
        select(-version)
    
    # fetch responses
    raw <- download_surveys(surveys)
    raw[[7]] <- rename_with(
        raw[[7]],
        function(x) gsub("cat_", "spa_", x), everything()
    )
    raw[[1]] <- raw[[1]] %>%
        # fix codes known to be wrong
        mutate(
            code = fix_code(na_if(code, "")),
            created = as_datetime(created)
        ) %>%
        # remove codes not included in participants
        filter(code %in% participants_tmp$code) %>%
        # get only last response of each code
        arrange(desc(created)) %>%
        distinct(code, .keep_all = TRUE) %>%
        # remove responses with no code
        filter(!is.na(code), !is.na(ended)) %>% 
        # fix codes known to be wrong
        fix_code_raw()
    
    # process data
    processed <- process_survey(raw, participants_tmp, version)
    
    if (interactive()) {
        n_responses <- nrow(distinct(processed, code))
        msg <- "{version} updated: {n_responses} response{?s} retrieved"
        cli_alert_success(msg)
    }
    
    return(processed)
}
