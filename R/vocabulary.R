#' Generate participant information and progress for each response
#'
#' This function generates a data frame with the vocabulary of each participant
#' (keeping longitudinal data from the same participant in different rows).
#' Comprehensive and productive vocabulary sizes are computed as raw counts
#' (`*_count`) and as proportions `*_prop`.
#'
#' @export bvq_vocabulary
#'
#' @import dplyr
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr pivot_wider
#' @importFrom janitor clean_names
#' @importFrom janitor make_clean_names
#' 
#' @param participants Participants data frame, as generated by
#'   [bvq::bvq_participants()].
#' @param responses Responses data frame, as generated by
#'   [bvq::bvq_responses()].
#' @param ... <[`dynamic-dots`][rlang::dyn-dots]> Unquoted name of the
#'   variable(s) to group data into. Vocabulary metrics will be calculated by
#'   aggregating responses within the groups that result from the combination of
#'   crossing of the variables provided in `...`. These variables can refer to
#'   item properties (see [bvq::pool], e.g., `semantic_category`) or to
#'   participant properties (see [bvq::bvq_logs()], e.g., `lp`).
#' @param .scale A character vector that takes the value `"count"` and/or
#'   `"prop"`. If `"prop"` (default), vocabulary metrics are calculated as
#'   proportions. If `"count"`, vocabulary metrics are reported as counts
#'   (number of words).
#'   
#' @returns A dataset (actually, a [tibble::tibble] with each participant's
#'   comprehensive and/or vocabulary size in each language. This data frame
#'   contains the following variables:
#' * id: a character string with five digits indicating a participant's identifier in the database from the [Laboratori de Recerca en Inf√†ncia](https://www.upf.edu/web/cbclab) at Universitat Pompeu Fabra. This value is always the same for each participant, so that different responses from the same participant share the same `id`.
#' * time: a numeric value indicating how many times a given participant has been sent the questionnaire, regardless of whether they completed it or not.
#' * age: a numeric value indicating the number of months elapsed since participants' birth date until they filled in the last item of their questionnaire response.
#' * type: a character string indicating the vocabulary type computed: `"understands"` if option "Understands" was selected, and `"produces"` if option "Understands & Says" was selected.
#' * total_count: integer indicating the number of items selected as "Understands" or "Understands and Says" in both languages.
#' * l1_count: positive integer indicating the number of items selected as "Understands" or "Understands and Says" in the dominant language (L1).
#' * l2_count: positive integer indicating the number of items selected as "Understands" or "Understands and Says" in the non-dominant language (L2).
#' * concept_count: positive integer indicating the number of translation equivalents (a.k.a. cross-language synonyms or doublets) in which  "at list one of the items was selected as "Understands" or "Understands and Says". This is a measure of the number of lexicalised concepts.
#' * te_count: positive integer indicating the number of translation equivalents (out of the total number of items the participant answered to) in which at both items was selected as "Understands" or "Understands and Says". This is a measure of the number of lexicalised concepts.
#' * total_prop: numeric value ranging from 0 to 1 (both included) indicating the proportion of items selected as "Understands" or "Understands and Says" in both languages.
#' * l1_prop: numeric value ranging from 0 to 1 (both included) indicating the proportion of of items selected as "Understands" or "Understands and Says" in the dominant language (L1).
#' * l2_prop: numeric value ranging from 0 to 1 (both included) indicating the proportion of of items selected as "Understands" or "Understands and Says" in the non-dominant language (L2).
#' * concept_prop: numeric value ranging from 0 to 1 (both included) indicating the proportion of of translation equivalents (a.k.a. cross-language synonyms or doublets) in which at least one of the items was selected as "Understands" or "Understands and Says". This is a measure of the number of lexicalised concepts.
#' * te_prop: numeric value ranging from 0 to 1 (both included) indicating the proportion of of translation equivalents (aka. cross-language synonyms or doublets) in which both items were selected as "Understands" or "Understands and Says". This is a measure of the number of lexicalised concepts.
#'   The specific subset of columns returned by [bvq::bvq_vocabulary()] depends
#'   on the elements of `...` and `.scale`.
#'   
#' @author Gonzalo Garcia-Castro
#' 
#' @md
#' 
bvq_vocabulary <- function(participants,
                           responses,
                           ...,
                           .scale = "prop") {
    if (missing(participants)) participants <- bvq_participants()
    if (missing(responses)) responses <- bvq_responses(participants)
    
    # get logs
    logs <- bvq_logs(participants, responses)
    logs <- logs[logs$id %in% unique(responses$id), ]
    
    # collect ... into a character vector for `any_of`
    dots_vctr <- as.character(match.call(expand.dots = FALSE)$`...`)
    
    # check if all extra ... are valid column names
    possible_colnames <- unlist(lapply(list(responses, logs, bvq::pool), colnames))
    check_arg_dots(dots_vctr, .cols = possible_colnames)
    
    if (!any(.scale %in% c("count", "prop"))) {
        cli_abort("Argument .scale must be 'count' and/or 'prop'")
    }
    
    # get main dataset
    base <- responses 
    base$understands <- base$response > 1
    base$produces <- base$response > 2
    base <- base[, names(base) != "response"]
    base <- pivot_longer(base,
                         c(understands, produces),
                         names_to = "type",
                         values_to = "response")
    base <- base[!is.na(base$response), ]
    
    # join TE-level properties
    cols.keep <- names(bvq::pool) %in% c("item", "te", "language", dots_vctr)
    pool_tmp <- bvq::pool[, cols.keep]
    base <- dplyr::inner_join(base,
                              pool_tmp,
                              multiple = "all",
                              by = join_by(item),
                              relationship = "many-to-many")
    
    # join participant-level properties
    cols.keep <- names(logs) %in% c("id", "time", "dominance", dots_vctr)
    logs_tmp <- logs[, cols.keep]
    base <- dplyr::inner_join(base, logs_tmp,
                              multiple = "all",
                              by = join_by(id, time),
                              relationship = "many-to-many")
    
    # define TE-by-participant properties
    base$item_dominance <- ifelse(base$language==base$dominance, "L1", "L2")
    cols.keep <- c("id", "time", "dominance", "item_dominance", "type",
                   "te", "item", dots_vctr, "response")
    base <- base[, cols.keep]
    
    # compute total denominator
    cols.distinct <- names(base) %in% c("id", "time", "te", dots_vctr)
    base_n <- base[!duplicated(base[, cols.distinct]), , drop = FALSE]
    base_n <- dplyr::count(base_n, 
                           dplyr::pick(id, time, type, ...), 
                           name = "n_total")
    cols.keep <- names(base_n) %in% c("id", "time", dots_vctr, "n_total")
    base_n <- base_n[, cols.keep]
    
    # compute TE-wise denominator
    base_te <- base[base$response, ]
    base_te <- dplyr::left_join(base_te, base_n,
                                by = join_by(id, time, ...))
    
    base_te <- tidyr::pivot_wider(
        base_te,
        names_from = item_dominance,
        values_from = response,
        values_fn = sum,
        values_fill = 0,
        id_cols = c(id, time, type, n_total, te, ...)
    )
    
    # total vocabulary
    total <- vocab_total(base, dots_vctr)
    dominance <- vocab_dominance(base, dots_vctr)
    concept <- vocab_concept(base_te, dots_vctr)
    te <- vocab_te(base_te, dots_vctr)
    
    # merge all datasets
    which_col_not <- c("count", "prop")[which(!(c("count", "prop") %in% .scale))]
    
    vocabulary <- list(total, dominance, concept, te) 
    vocabulary <- reduce(vocabulary,
                         dplyr::left_join,
                         multiple = "all",
                         by = join_by(id, time, type, ...)) 
    cols.integer <- names(vocabulary)[grepl("concept|te", names(vocabulary))]
    vocabulary[, cols.integer] <- lapply(vocabulary[, cols.integer],
                                         function(x) {
                                             ifelse(is.na(x), as.integer(0), x)
                                         })
    cols.scale <- names(vocabulary)[grepl(paste(.scale, collapse = "|"),
                                          names(vocabulary))]
    cols.keep <- c("id", "time", "type",
                   dots_vctr,
                   cols.scale[cols.scale %in% cols.scale[grepl("prop$", cols.scale)]],
                   cols.scale[cols.scale %in% cols.scale[grepl("count$", cols.scale)]])
    vocabulary <- vocabulary[, cols.keep]
    vocabulary <- vocabulary[, !(names(vocabulary) %in% which_col_not)]
    vocabulary <- tibble::as_tibble(vocabulary)
    
    return(vocabulary)
}



#' Check argument `...` in the [bvq::bvq_vocabulary()] function
#'
#' @param x Variable names passed with `...`
#' @param .cols Valid column names
#'
#' @importFrom cli  cli_abort
#' @noRd
check_arg_dots <- function(x, .cols) { # nocov start
    
    is_valid <- x %in% .cols
    
    if (!all(is_valid)) {
        which_missing <- x[which(is_valid)]
        cli_msg <- "{.code ...} contains element{?s} {which_missing}, which {?is/are} \
    not a variable in `logs`, `pool`, or `responses`"
        cli_abort(cli_msg)
    }
} # nocov end

#' Compute total vocabulary (L1 + L2)
#'
#' @param x Base data frame from which to calculate total vocabulary size
#' 
#' @inheritParams bvq_vocabulary
#' 
#' @noRd
#' @keywords internal
#' 
vocab_total <- function(x, ...) { # nocov start
    out <- x %>%
        summarise(
            total_count = sum(response, na.rm = TRUE),
            n_total = n(),
            .by = c(id, time, type, any_of(...))
        ) %>%
        mutate(total_prop = ifelse(n_total == 0, 0, total_count / n_total))
    
    return(out)
} # nocov end

#' Compute dominance vocabulary (L1, L2)
#'
#' @inheritParams bvq_vocabulary
#' @inheritParams vocab_total
#' 
#' @noRd
#' @keywords internal
#' 
vocab_dominance <- function(x, ...) { # nocov start
    
    out <- x %>%
        summarise(
            count = sum(response, na.rm = TRUE),
            n_total = sum(!is.na(response)),
            .by = c(id, time, type, item_dominance, any_of(...))
        ) %>%
        mutate(prop = ifelse(n_total == 0, 0, count / n_total)) %>%
        pivot_wider(
            names_from = item_dominance,
            values_from = c(n_total, matches("count|prop")),
            names_glue = "{item_dominance}_{.value}",
            names_repair = make_clean_names
        ) %>%
        clean_names() %>%
        select(
            id, time, type, starts_with("l1_"), starts_with("l2_"),
            -ends_with("n_total"), any_of(...)
        )
    
    return(out)
} # nocov end

#' Compute conceptual vocabulary (L1 or L2)
#'
#' @inheritParams bvq_vocabulary
#' @inheritParams vocab_total
#' 
#' @noRd
#' @keywords internal
#' 
vocab_concept <- function(x, ...) { # nocov start
    
    out <- x %>%
        mutate(across(c(L1, L2), function(x) x > 0),
               is_any = rowSums(pick(L2:L1)),
               is_any = is_any > 0
        ) %>%
        summarise(
            n = sum(is_any),
            .by = c(id, time, type, n_total, any_of(...))
        ) %>%
        rename(concept_count = n) %>%
        mutate(
            concept_count = as.integer(concept_count),
            concept_prop = ifelse(n_total == 0, 0, concept_count / n_total)
        ) %>%
        select(id, time, type, concept_count, concept_prop, any_of(...))
    
    return(out)
} # nocov end

#' Compute translation equivalent vocabulary (L1 & L2)
#'
#' @inheritParams bvq_vocabulary
#' @inheritParams vocab_total
#' 
#' @noRd
#' @keywords internal
#' 
vocab_te <- function(x, ...) { # nocov start
    
    out <- x %>%
        mutate(across(c(L1, L2), function(x) x > 0),
               is_both = rowSums(pick(c(L2, L1))),
               is_both = is_both > 1
        ) %>%
        summarise(
            n = sum(is_both),
            .by = c(id, time, type, n_total, any_of(...))
        ) %>%
        rename(te_count = n) %>%
        mutate(
            te_count = as.integer(te_count),
            te_prop = ifelse(n_total == 0, 0, te_count / n_total)
        ) %>%
        select(id, time, type, te_count, te_prop, any_of(...))
    
    return(out)
} # nocov end
